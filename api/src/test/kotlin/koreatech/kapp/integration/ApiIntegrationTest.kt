package koreatech.kapp.integration

import com.fasterxml.jackson.databind.ObjectMapper
import org.hamcrest.Matchers
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.http.MediaType
import org.springframework.test.web.servlet.MockMvc
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status
import java.time.LocalDate
import javax.sql.DataSource
import kotlin.test.assertEquals

@SpringBootTest(
    properties = [
        "spring.profiles.active=local",
        "spring.datasource.driver-class-name=org.h2.Driver",
        "spring.datasource.url=jdbc:h2:mem:kapp_api_integration;MODE=PostgreSQL;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false",
        "spring.datasource.username=sa",
        "spring.datasource.password=",
        "kapp.jwt.secret-key=integration-test-jwt-secret-key",
        "kapp.jwt.access-token-expiration-period-day=7"
    ]
)
@AutoConfigureMockMvc
class ApiIntegrationTest @Autowired constructor(
    private val mockMvc: MockMvc,
    private val dataSource: DataSource,
    private val objectMapper: ObjectMapper
) {
    private lateinit var targetDate: LocalDate

    @BeforeEach
    fun setUp() {
        targetDate = LocalDate.now()

        dataSource.connection.use { connection ->
            connection.createStatement().use { statement ->
                statement.execute("""drop table if exists "meal_menu_items"""")
                statement.execute("""drop table if exists "meals"""")
                statement.execute("""drop table if exists "users"""")

                statement.execute(
                    """
                    create table "users" (
                      "id" bigint generated by default as identity primary key,
                      "email" varchar(255) not null,
                      "password" varchar(255) not null,
                      "name" varchar(100) not null,
                      "student_employee_id" varchar(50) not null,
                      "created_at" timestamp not null,
                      "updated_at" timestamp not null
                    )
                    """.trimIndent()
                )

                statement.execute(
                    """
                    create table "meals" (
                      "id" bigint generated by default as identity primary key,
                      "date" date not null,
                      "dining_time" varchar(20) not null,
                      "place" varchar(100) not null,
                      "price" varchar(20) not null,
                      "kcal" varchar(10) not null,
                      "created_at" timestamp not null,
                      "updated_at" timestamp not null
                    )
                    """.trimIndent()
                )

                statement.execute(
                    """
                    create table "meal_menu_items" (
                      "meal_id" bigint not null,
                      "menu_item" varchar(200) not null
                    )
                    """.trimIndent()
                )
            }

            insertMeal(connection, 1L, targetDate.toString(), "breakfast", "학생식당", "4500", "420")
            insertMeal(connection, 2L, targetDate.toString(), "lunch", "학생식당", "6500", "900")
            insertMeal(connection, 3L, targetDate.toString(), "dinner", "코너1", "5000", "480")

            insertMenu(connection, 1L, "두부조림")
            insertMenu(connection, 1L, "밥")
            insertMenu(connection, 2L, "제육볶음")
            insertMenu(connection, 2L, "김치")
            insertMenu(connection, 3L, "샐러드")
            insertMenu(connection, 3L, "스프")
        }
    }

    @Test
    fun `should call all meal endpoints with lowercase dining_time data`() {
        val date = targetDate.toString()

        mockMvc.perform(get("/api/meals"))
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.totalCount").value(3))

        mockMvc.perform(get("/api/meals").param("date", date))
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.totalCount").value(3))
            .andExpect(jsonPath("$.meals[*].diningTime", Matchers.hasItems("BREAKFAST", "LUNCH", "DINNER")))

        mockMvc.perform(get("/api/meals").param("date", date).param("diningTime", "LUNCH"))
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.totalCount").value(1))
            .andExpect(jsonPath("$.meals[0].diningTime").value("LUNCH"))

        mockMvc.perform(get("/api/meals").param("date", date).param("place", "학생식당"))
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.totalCount").value(2))

        mockMvc.perform(
            get("/api/meals/detail")
                .param("date", date)
                .param("diningTime", "BREAKFAST")
                .param("place", "학생식당")
        )
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.diningTime").value("BREAKFAST"))
            .andExpect(jsonPath("$.diningTimeDisplay").value("아침"))

        mockMvc.perform(get("/api/meals/low-calorie").param("date", date))
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.totalCount").value(2))

        mockMvc.perform(get("/api/meals/vegetarian").param("date", date))
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.totalCount").value(2))

        mockMvc.perform(get("/api/meals/today"))
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.totalCount").value(3))

        assertEquals(3, count("select count(*) from meals where dining_time in ('breakfast', 'lunch', 'dinner')"))
        assertEquals(0, count("select count(*) from meal_menu_items mmi left join meals m on m.id = mmi.meal_id where m.id is null"))
    }

    @Test
    fun `should complete auth flow and persist user in db`() {
        val suffix = System.currentTimeMillis()
        val email = "integration-$suffix@example.com"
        val password = "Pw!${suffix}x"

        val registerBody = """
            {
              "email": "$email",
              "password": "$password",
              "name": "Integration$suffix",
              "studentEmployeeId": "S$suffix"
            }
        """.trimIndent()

        mockMvc.perform(
            post("/api/auth/register")
                .contentType(MediaType.APPLICATION_JSON)
                .content(registerBody)
        )
            .andExpect(status().isCreated)
            .andExpect(jsonPath("$.user.email").value(email))

        val loginResult = mockMvc.perform(
            post("/api/auth/login")
                .contentType(MediaType.APPLICATION_JSON)
                .content("""{"email":"$email","password":"$password"}""")
        )
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.token").isString)
            .andReturn()

        val token = objectMapper.readTree(loginResult.response.contentAsString)["token"].asText()

        mockMvc.perform(
            get("/api/auth/me")
                .header("Authorization", "Bearer $token")
        )
            .andExpect(status().isOk)
            .andExpect(jsonPath("$.email").value(email))

        assertEquals(1, count("select count(*) from users where email = ?", email))
    }

    private fun insertMeal(
        connection: java.sql.Connection,
        id: Long,
        date: String,
        diningTime: String,
        place: String,
        price: String,
        kcal: String
    ) {
        connection.prepareStatement(
            """
            insert into meals (id, date, dining_time, place, price, kcal, created_at, updated_at)
            values (?, ?, ?, ?, ?, ?, current_timestamp, current_timestamp)
            """.trimIndent()
        ).use { statement ->
            statement.setLong(1, id)
            statement.setString(2, date)
            statement.setString(3, diningTime)
            statement.setString(4, place)
            statement.setString(5, price)
            statement.setString(6, kcal)
            statement.executeUpdate()
        }
    }

    private fun insertMenu(connection: java.sql.Connection, mealId: Long, menuItem: String) {
        connection.prepareStatement(
            """insert into meal_menu_items (meal_id, menu_item) values (?, ?)"""
        ).use { statement ->
            statement.setLong(1, mealId)
            statement.setString(2, menuItem)
            statement.executeUpdate()
        }
    }

    private fun count(query: String, vararg params: Any): Int {
        dataSource.connection.use { connection ->
            connection.prepareStatement(query).use { statement ->
                params.forEachIndexed { index, value ->
                    statement.setObject(index + 1, value)
                }
                statement.executeQuery().use { rs ->
                    rs.next()
                    return rs.getInt(1)
                }
            }
        }
    }
}
