# Infra Module Specification

## Overview
The **Infra Module** handles all infrastructure concerns including database persistence, external service integration, and technical implementations. This module implements interfaces defined in the core module and handles technical details hidden from domain logic.

## Technology Stack
- Kotlin 1.9.25
- Java 21
- JooQ 3.20.7 (Type-safe SQL)
- Spring Security Crypto (BCrypt)
- PostgreSQL (or your database)

## Architecture Principles
- **Implementation of Core Interfaces**: Implements repository interfaces from core
- **Technical Details Isolation**: Hide database and technical concerns from domain
- **Type-Safe SQL**: Use JooQ for compile-time SQL validation
- **Transaction Management**: Handle transactional boundaries
- **Data Mapping**: Map between database records and domain objects

## Directory Structure

```
infra/
└── src/main/kotlin/koreatech/kapp/
    ├── config/
    │   └── PasswordEncoderImpl.kt        # BCrypt password encoding
    └── persistence/
        ├── user/                          # User persistence layer
        │   ├── DBUserRepository.kt        # User repository implementation
        │   ├── UserEntity.kt              # Database entity mapping
        │   └── UserTable.kt               # JooQ table definition
        └── meal/                          # Meal persistence layer
            ├── DBMealRepository.kt        # Meal repository implementation
            ├── MealEntity.kt              # Database entity mapping
            └── MealTable.kt               # JooQ table definition
```

## Component Specifications

### 1. Password Encoding

#### PasswordEncoderImpl
**Purpose**: Provide secure password hashing using BCrypt

**Specifications**:
- Implements a password encoding interface (consider defining in core)
- Uses BCrypt algorithm with salt
- **Methods**:
  - `encode(rawPassword: String): String` - Hash raw password
  - `matches(rawPassword: String, encodedPassword: String): Boolean` - Verify password

**Security Requirements**:
- Use BCrypt strength 10 or higher
- Never store raw passwords
- Salt is automatically generated by BCrypt
- One-way hashing (cannot decrypt)

**Example Usage**:
```kotlin
val encoder = PasswordEncoderImpl()
val hashed = encoder.encode("myPassword123")  // $2a$10$...
val isValid = encoder.matches("myPassword123", hashed)  // true
```

**Implementation Notes**:
- Uses Spring Security Crypto library
- Thread-safe implementation
- Consider making it a Spring bean for dependency injection

### 2. User Persistence Layer

#### UserTable (JooQ Definition)
**Purpose**: Define user table schema for type-safe SQL queries

**Specifications**:
- Table name: `users` (or as defined in database)
- **Columns**:
  - `id`: BIGSERIAL PRIMARY KEY
  - `email`: VARCHAR(255) UNIQUE NOT NULL
  - `password`: VARCHAR(255) NOT NULL
  - `nickname`: VARCHAR(255) NOT NULL
  - Consider adding: `created_at`, `updated_at`

**JooQ Configuration**:
- Generated from actual database schema
- Type-safe column references
- Compile-time SQL validation

**Example**:
```kotlin
object UserTable : Table<UserRecord>("users") {
    val ID = createField("id", SQLDataType.BIGINT)
    val EMAIL = createField("email", SQLDataType.VARCHAR(255))
    val PASSWORD = createField("password", SQLDataType.VARCHAR(255))
    val NICKNAME = createField("nickname", SQLDataType.VARCHAR(255))
}
```

#### UserEntity
**Purpose**: Intermediate representation between database records and domain objects

**Specifications**:
- Data class mapping to database columns
- **Fields**:
  - `id: Long?`
  - `email: String`
  - `password: String`
  - `nickname: String`

**Responsibilities**:
- Map from JooQ Record to Entity
- Map from Entity to Domain Object
- Handle nullable ID for new entities

**Example**:
```kotlin
data class UserEntity(
    val id: Long?,
    val email: String,
    val password: String,
    val nickname: String
) {
    fun toDomain(): User {
        return User(
            id = id,
            email = Email(email),
            password = password,
            nickname = nickname
        )
    }

    companion object {
        fun fromDomain(user: User): UserEntity {
            return UserEntity(
                id = user.id,
                email = user.email.value,
                password = user.password,
                nickname = user.nickname
            )
        }
    }
}
```

#### DBUserRepository
**Purpose**: Implement UserRepository interface using JooQ

**Specifications**:
- Implements `UserRepository` from core module
- Uses JooQ DSL for type-safe queries
- Handles transaction boundaries

**Method Implementations**:

1. **save(user: User): User**
   - Insert if ID is null
   - Update if ID exists
   - Return user with generated ID
   - Handle unique constraint violations

2. **findByEmail(email: Email): User?**
   - Query by email column
   - Return null if not found
   - Map record to domain object

3. **existsByEmail(email: Email): Boolean**
   - Check existence without fetching full record
   - Use COUNT or EXISTS query
   - Return boolean

**Example Implementation**:
```kotlin
@Repository
class DBUserRepository(
    private val dsl: DSLContext
) : UserRepository {

    override fun save(user: User): User {
        val entity = UserEntity.fromDomain(user)

        return if (entity.id == null) {
            // Insert new user
            val id = dsl.insertInto(UserTable)
                .set(UserTable.EMAIL, entity.email)
                .set(UserTable.PASSWORD, entity.password)
                .set(UserTable.NICKNAME, entity.nickname)
                .returning(UserTable.ID)
                .fetchOne()
                ?.get(UserTable.ID)
                ?: throw IllegalStateException("Failed to generate user ID")

            user.copy(id = id)
        } else {
            // Update existing user
            dsl.update(UserTable)
                .set(UserTable.EMAIL, entity.email)
                .set(UserTable.PASSWORD, entity.password)
                .set(UserTable.NICKNAME, entity.nickname)
                .where(UserTable.ID.eq(entity.id))
                .execute()

            user
        }
    }

    override fun findByEmail(email: Email): User? {
        return dsl.selectFrom(UserTable)
            .where(UserTable.EMAIL.eq(email.value))
            .fetchOne()
            ?.let { record ->
                UserEntity(
                    id = record.get(UserTable.ID),
                    email = record.get(UserTable.EMAIL),
                    password = record.get(UserTable.PASSWORD),
                    nickname = record.get(UserTable.NICKNAME)
                ).toDomain()
            }
    }

    override fun existsByEmail(email: Email): Boolean {
        return dsl.fetchExists(
            dsl.selectOne()
                .from(UserTable)
                .where(UserTable.EMAIL.eq(email.value))
        )
    }
}
```

**Error Handling**:
- Catch and translate SQL exceptions
- Handle unique constraint violations gracefully
- Log errors appropriately
- Consider custom infrastructure exceptions

### 3. Meal Persistence Layer

#### MealTable (JooQ Definition)
**Purpose**: Define meal table schema for type-safe SQL queries

**Specifications**:
- Table name: `meals` (or as defined in database)
- **Columns**:
  - `id`: BIGSERIAL PRIMARY KEY
  - `name`: VARCHAR(255) NOT NULL
  - `price`: INTEGER NOT NULL
  - `calories`: INTEGER NOT NULL
  - `menu`: TEXT or JSONB (array of strings)
  - Consider adding: `created_at`, `updated_at`

**Schema Design Decisions**:
- Store price as integer (cents or won)
- Store calories as integer
- Store menu as JSONB array for flexibility

**Example**:
```kotlin
object MealTable : Table<MealRecord>("meals") {
    val ID = createField("id", SQLDataType.BIGINT)
    val NAME = createField("name", SQLDataType.VARCHAR(255))
    val PRICE = createField("price", SQLDataType.INTEGER)
    val CALORIES = createField("calories", SQLDataType.INTEGER)
    val MENU = createField("menu", SQLDataType.JSONB)  // or TEXT
}
```

#### MealEntity
**Purpose**: Intermediate representation between database records and domain objects

**Specifications**:
- Data class mapping to database columns
- **Fields**:
  - `id: Long?`
  - `name: String`
  - `price: Int`
  - `calories: Int`
  - `menu: List<String>`

**Mapping Responsibilities**:
- Convert menu list to/from JSONB
- Create domain value objects from primitives
- Handle nullable ID

**Example**:
```kotlin
data class MealEntity(
    val id: Long?,
    val name: String,
    val price: Int,
    val calories: Int,
    val menu: List<String>
) {
    fun toDomain(): Meal {
        return Meal(
            id = id,
            name = name,
            price = Money(price),
            calories = Calories(calories),
            menu = Menu(menu)
        )
    }

    companion object {
        fun fromDomain(meal: Meal): MealEntity {
            return MealEntity(
                id = meal.id,
                name = meal.name,
                price = meal.price.amount,
                calories = meal.calories.value,
                menu = meal.menu.items
            )
        }
    }
}
```

#### DBMealRepository
**Purpose**: Implement MealRepository interface using JooQ

**Specifications**:
- Implements `MealRepository` from core module
- Uses JooQ DSL for queries
- Handles JSON serialization for menu

**Method Implementations**:

1. **save(meal: Meal): Meal**
   - Insert if ID is null
   - Update if ID exists
   - Serialize menu to JSONB
   - Return meal with generated ID

2. **findById(id: Long): Meal?**
   - Query by primary key
   - Deserialize menu from JSONB
   - Return null if not found

3. **findAll(): List<Meal>**
   - Query all meals
   - Order by ID or created_at
   - Return empty list if none exist
   - Consider pagination for large datasets

**Example Implementation**:
```kotlin
@Repository
class DBMealRepository(
    private val dsl: DSLContext,
    private val objectMapper: ObjectMapper
) : MealRepository {

    override fun save(meal: Meal): Meal {
        val entity = MealEntity.fromDomain(meal)
        val menuJson = objectMapper.writeValueAsString(entity.menu)

        return if (entity.id == null) {
            val id = dsl.insertInto(MealTable)
                .set(MealTable.NAME, entity.name)
                .set(MealTable.PRICE, entity.price)
                .set(MealTable.CALORIES, entity.calories)
                .set(MealTable.MENU, JSONB.valueOf(menuJson))
                .returning(MealTable.ID)
                .fetchOne()
                ?.get(MealTable.ID)
                ?: throw IllegalStateException("Failed to generate meal ID")

            meal.copy(id = id)
        } else {
            dsl.update(MealTable)
                .set(MealTable.NAME, entity.name)
                .set(MealTable.PRICE, entity.price)
                .set(MealTable.CALORIES, entity.calories)
                .set(MealTable.MENU, JSONB.valueOf(menuJson))
                .where(MealTable.ID.eq(entity.id))
                .execute()

            meal
        }
    }

    override fun findById(id: Long): Meal? {
        return dsl.selectFrom(MealTable)
            .where(MealTable.ID.eq(id))
            .fetchOne()
            ?.let { record ->
                val menuList = objectMapper.readValue(
                    record.get(MealTable.MENU).data(),
                    object : TypeReference<List<String>>() {}
                )

                MealEntity(
                    id = record.get(MealTable.ID),
                    name = record.get(MealTable.NAME),
                    price = record.get(MealTable.PRICE),
                    calories = record.get(MealTable.CALORIES),
                    menu = menuList
                ).toDomain()
            }
    }

    override fun findAll(): List<Meal> {
        return dsl.selectFrom(MealTable)
            .orderBy(MealTable.ID)
            .fetch()
            .map { record ->
                val menuList = objectMapper.readValue(
                    record.get(MealTable.MENU).data(),
                    object : TypeReference<List<String>>() {}
                )

                MealEntity(
                    id = record.get(MealTable.ID),
                    name = record.get(MealTable.NAME),
                    price = record.get(MealTable.PRICE),
                    calories = record.get(MealTable.CALORIES),
                    menu = menuList
                ).toDomain()
            }
    }
}
```

## Database Schema

### User Table
```sql
CREATE TABLE users (
    id BIGSERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255) NOT NULL,
    nickname VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
```

### Meal Table
```sql
CREATE TABLE meals (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    price INTEGER NOT NULL CHECK (price >= 0),
    calories INTEGER NOT NULL CHECK (calories >= 0),
    menu JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_meals_name ON meals(name);
```

## Development Guidelines

### Adding New Repository Implementation

1. **Create Table Definition**:
   - Define JooQ table object
   - Map all columns with correct types
   - Use JooQ code generation when possible

2. **Create Entity Class**:
   - Data class with primitive types
   - `toDomain()` method to convert to domain object
   - `fromDomain()` companion method for reverse mapping

3. **Implement Repository Interface**:
   - Annotate with `@Repository`
   - Inject DSLContext for JooQ queries
   - Implement all interface methods
   - Handle errors appropriately

4. **Write Integration Tests**:
   - Test with actual database (test containers recommended)
   - Verify save/update logic
   - Test query methods
   - Verify transaction handling

### JooQ Best Practices

1. **Type Safety**:
   - Always use table field references (e.g., `UserTable.EMAIL`)
   - Avoid raw SQL strings when possible
   - Let compiler catch SQL errors

2. **Query Optimization**:
   - Use `fetchOne()` for single results
   - Use `fetch()` for multiple results
   - Add indexes for frequently queried columns
   - Consider pagination for large datasets

3. **Transaction Management**:
   - Use `@Transactional` at service layer, not repository
   - Keep transactions short
   - Avoid nested transactions
   - Handle rollback scenarios

4. **Error Handling**:
   - Catch `DataAccessException`
   - Translate to domain exceptions when appropriate
   - Log SQL errors with context
   - Don't expose SQL details to upper layers

### JSON Handling for Complex Fields

**For Menu Field**:
```kotlin
// Serialization
val menuJson = objectMapper.writeValueAsString(menu)
.set(MealTable.MENU, JSONB.valueOf(menuJson))

// Deserialization
val menu: List<String> = objectMapper.readValue(
    record.get(MealTable.MENU).data(),
    object : TypeReference<List<String>>() {}
)
```

**Considerations**:
- Use Jackson ObjectMapper for JSON operations
- Define reusable helper methods for common conversions
- Consider creating custom JooQ converters
- Handle JSON parsing errors gracefully

## Testing Guidelines

### Integration Testing Requirements

1. **Database Setup**:
   - Use Testcontainers for PostgreSQL
   - Run migrations before tests
   - Clean database between tests
   - Use transaction rollback for isolation

2. **Test Repository Implementations**:
   - Test insert operations
   - Test update operations
   - Test query methods
   - Test unique constraints
   - Test null handling
   - Test transactions

3. **Example Test**:
```kotlin
@SpringBootTest
@Testcontainers
class DBUserRepositoryTest {

    @Container
    val postgres = PostgreSQLContainer<Nothing>("postgres:15-alpine")

    @Autowired
    lateinit var repository: DBUserRepository

    @Autowired
    lateinit var dsl: DSLContext

    @BeforeEach
    fun cleanup() {
        dsl.deleteFrom(UserTable).execute()
    }

    @Test
    fun `should save new user and generate ID`() {
        // Given
        val user = User(
            id = null,
            email = Email("test@example.com"),
            password = "hashed",
            nickname = "Test"
        )

        // When
        val saved = repository.save(user)

        // Then
        assertThat(saved.id).isNotNull()
        assertThat(saved.email).isEqualTo(user.email)
    }

    @Test
    fun `should find user by email`() {
        // Given
        val user = createAndSaveUser("test@example.com")

        // When
        val found = repository.findByEmail(Email("test@example.com"))

        // Then
        assertThat(found).isNotNull()
        assertThat(found?.id).isEqualTo(user.id)
    }
}
```

## Dependencies

### Required Dependencies
```kotlin
dependencies {
    implementation(project(":core"))  // Core domain module

    // JooQ
    implementation("org.jooq:jooq:3.20.7")
    implementation("org.jooq:jooq-kotlin:3.20.7")

    // Database
    implementation("org.postgresql:postgresql")

    // Spring Security (for BCrypt)
    implementation("org.springframework.security:spring-security-crypto")

    // JSON
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")

    // Testing
    testImplementation("org.testcontainers:postgresql")
}
```

## Configuration

### JooQ Code Generation
Configure JooQ to generate code from database schema:

```kotlin
// build.gradle.kts
jooq {
    configurations {
        create("main") {
            jooqConfiguration.apply {
                jdbc.apply {
                    url = "jdbc:postgresql://localhost:5432/kapp"
                    user = "postgres"
                    password = "password"
                }
                generator.apply {
                    database.apply {
                        name = "org.jooq.meta.postgres.PostgresDatabase"
                        includes = ".*"
                        excludes = "flyway_schema_history"
                    }
                    target.apply {
                        packageName = "koreatech.kapp.generated"
                        directory = "src/main/generated"
                    }
                }
            }
        }
    }
}
```

### Database Connection
Configure in `application.yml` (API module):
```yaml
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/kapp
    username: postgres
    password: password
    driver-class-name: org.postgresql.Driver
```

## Performance Considerations

### Query Optimization
1. **Indexes**: Create indexes on frequently queried columns
2. **Batch Operations**: Use batch inserts for bulk data
3. **Lazy Loading**: Avoid N+1 queries
4. **Connection Pooling**: Configure HikariCP appropriately

### Caching Strategy
Consider caching for:
- Frequently accessed meals
- User authentication data
- Reference data that rarely changes

**Implementation**:
- Spring Cache abstraction
- Redis for distributed caching
- Cache invalidation on updates

## Security Considerations

1. **Password Storage**:
   - Always use BCrypt with appropriate strength
   - Never log passwords
   - Use parameterized queries (JooQ handles this)

2. **SQL Injection Prevention**:
   - JooQ provides automatic parameterization
   - Never concatenate user input into queries
   - Validate input at API layer

3. **Data Access Control**:
   - Implement row-level security if needed
   - Filter sensitive data in repository layer
   - Audit data access

## Future Enhancements

1. **Audit Trail**:
   - Track created_at and updated_at
   - Record user who made changes
   - Store change history

2. **Soft Delete**:
   - Add deleted_at column
   - Filter deleted records in queries
   - Implement restore functionality

3. **Read Replicas**:
   - Configure separate read/write datasources
   - Route queries to read replicas
   - Handle replication lag

4. **Database Migration**:
   - Use Flyway or Liquibase
   - Version control schema changes
   - Test migrations in CI/CD

5. **Performance Monitoring**:
   - Log slow queries
   - Monitor connection pool metrics
   - Track query execution times

## Review Checklist

Before committing changes to infra module:
- [ ] Repository implements core interface correctly
- [ ] Entity mapping handles all domain fields
- [ ] Database schema supports domain requirements
- [ ] Indexes added for query performance
- [ ] Integration tests cover all repository methods
- [ ] Error handling translates technical to domain errors
- [ ] No domain logic leaked into persistence layer
- [ ] Transactions handled appropriately
- [ ] JooQ code generation configured correctly
- [ ] Documentation updated for new repositories
